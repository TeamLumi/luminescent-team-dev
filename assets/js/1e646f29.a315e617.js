"use strict";(globalThis.webpackChunkluminescent_team=globalThis.webpackChunkluminescent_team||[]).push([[536832],{28453(e,n,t){t.d(n,{R:()=>r,x:()=>c});var i=t(296540);const s={},a=i.createContext(s);function r(e){const n=i.useContext(a);return i.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function c(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:r(e.components),i.createElement(a.Provider,{value:n},e.children)}},565591(e,n,t){t.r(n),t.d(n,{assets:()=>l,contentTitle:()=>c,default:()=>h,frontMatter:()=>r,metadata:()=>i,toc:()=>o});const i=JSON.parse('{"id":"exefs/headers","title":"Headers","description":"Introduction","source":"@site/rom-hacking/exefs/headers.md","sourceDirName":"exefs","slug":"/exefs/headers","permalink":"/luminescent-team-dev/rom-hacking/exefs/headers","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{},"sidebar":"docs","previous":{"title":"Setting Up ExLaunch","permalink":"/luminescent-team-dev/rom-hacking/exefs/exlaunch"},"next":{"title":"Hooks","permalink":"/luminescent-team-dev/rom-hacking/exefs/hooks"}}');var s=t(474848),a=t(28453);const r={},c="Headers",l={},o=[{value:"Introduction",id:"introduction",level:2},{value:"il2cpp.h",id:"il2cpph",level:2},{value:"Complete Example",id:"complete-example",level:2},{value:"ILClass vs ILStruct",id:"ilclass-vs-ilstruct",level:2},{value:"In il2cpp.h",id:"in-il2cpph",level:3},{value:"In dump.cs",id:"in-dumpcs",level:3},{value:"Referencing internal functions",id:"referencing-internal-functions",level:2},{value:"Non-static function",id:"non-static-function",level:3},{value:"Static function",id:"static-function",level:3},{value:"MethodInfo",id:"methodinfo",level:3},{value:"Usage",id:"usage",level:2},{value:"Ghidra type equivalence",id:"ghidra-type-equivalence",level:3},{value:"New instance",id:"new-instance",level:3}];function d(e){const n={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,a.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.header,{children:(0,s.jsx)(n.h1,{id:"headers",children:"Headers"})}),"\n",(0,s.jsx)(n.h2,{id:"introduction",children:"Introduction"}),"\n",(0,s.jsxs)(n.p,{children:["Headers allow us to define a few things. They allow us to use cleaner manually created types than those provided in ",(0,s.jsx)(n.code,{children:"il2cpp.h"})," and they allow us to reference methods in the main program."]}),"\n",(0,s.jsx)(n.h2,{id:"il2cpph",children:"il2cpp.h"}),"\n",(0,s.jsxs)(n.p,{children:["The ",(0,s.jsx)(n.code,{children:"il2cpp.h"})," header includes all the types defined in the main program but they are not very pretty, they're all in the global namespace and have poor names. We do not include that file in the repo as we want to have clean types that are easier to deal with. When you want to use a specific type that is not available yet, you should create a new header in the ",(0,s.jsx)(n.code,{children:"src/mod/externals"})," directory."]}),"\n",(0,s.jsx)(n.h2,{id:"complete-example",children:"Complete Example"}),"\n",(0,s.jsx)(n.p,{children:"See here an example header file for the PokemonParam Class. It includes function definitions, a super class, nested namespaces, the TypeInfo, etc."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",metastring:'title="src/mod/externals/Pml/PokePara/PokemonParam.h"',children:'#pragma once\r\n\r\n#include "externals/il2cpp-api.h"\r\n\r\n#include "externals/Pml/PokePara/CoreParam.h"\r\n#include "externals/Pml/PokePara/InitialSpec.h"\r\n#include "externals/System/Primitives.h"\r\n\r\nnamespace Pml::PokePara {\r\n  struct PokemonParam : ILClass<PokemonParam, 0x04c59c10> {\r\n    struct Fields : CoreParam::Fields {\r\n      // No new fields\r\n    };\r\n\r\n    struct StaticFields {\r\n      System::Byte_array* sParamSerializeBuffer;\r\n    };\r\n\r\n    inline void ctor(int32_t monsno, uint16_t level, uint64_t id) {\r\n      external<void>(0x02054fe0, this, monsno, level, id);\r\n    }\r\n\r\n    inline void ctor(Pml::PokePara::InitialSpec::Object* spec) {\r\n      external<void>(0x02055140, this, spec);\r\n    }\r\n  };\r\n}\n'})}),"\n",(0,s.jsxs)(n.p,{children:["The offset given as a template argument to ",(0,s.jsx)(n.code,{children:"ILClass"})," points to the TypeInfo of the type you're defining. This is generally only needed if you need to access static fields or need to create a new instance."]}),"\n",(0,s.jsxs)(n.p,{children:["If the type you're defining has a parent type (when the first field is named ",(0,s.jsx)(n.code,{children:"super"})," in ",(0,s.jsx)(n.code,{children:"il2cpp.h"}),"), you should inherit its fields by making the inner ",(0,s.jsx)(n.code,{children:"Fields"})," struct that you're defining a derived struct of the ",(0,s.jsx)(n.code,{children:"Fields"})," struct of the parent type. If that was too confusing to follow, just remember that this is how you do it:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:"struct Fields : Parent::Fields {\r\n  // New fields\r\n};\n"})}),"\n",(0,s.jsx)(n.h2,{id:"ilclass-vs-ilstruct",children:"ILClass vs ILStruct"}),"\n",(0,s.jsxs)(n.p,{children:["There are a few ways to determine if the header you're creating should be an ",(0,s.jsx)(n.code,{children:"ILClass"})," or an ",(0,s.jsx)(n.code,{children:"ILStruct"}),"."]}),"\n",(0,s.jsx)(n.h3,{id:"in-il2cpph",children:"In il2cpp.h"}),"\n",(0,s.jsxs)(n.p,{children:["You can check the ",(0,s.jsx)(n.code,{children:"Object"})," struct for the type you're creating in ",(0,s.jsx)(n.code,{children:"il2cpp.h"})," (The one that ends in ",(0,s.jsx)(n.code,{children:"_o"}),"). If there are both a ",(0,s.jsx)(n.code,{children:"klass"})," and ",(0,s.jsx)(n.code,{children:"monitor"})," field, then an ",(0,s.jsx)(n.code,{children:"ILClass"})," should be used. If there is only the ",(0,s.jsx)(n.code,{children:"fields"})," field, then an ",(0,s.jsx)(n.code,{children:"ILStruct"})," is appropriate."]}),"\n",(0,s.jsx)(n.h3,{id:"in-dumpcs",children:"In dump.cs"}),"\n",(0,s.jsxs)(n.p,{children:["The type you're looking for will be defined either as a ",(0,s.jsx)(n.code,{children:"class"})," or a ",(0,s.jsx)(n.code,{children:"struct"})," in this file. No need to think too much about it: ",(0,s.jsx)(n.code,{children:"class"})," corresponds to ",(0,s.jsx)(n.code,{children:"ILClass"})," and ",(0,s.jsx)(n.code,{children:"struct"})," corresponds to ",(0,s.jsx)(n.code,{children:"ILStruct"}),"."]}),"\n",(0,s.jsx)(n.h2,{id:"referencing-internal-functions",children:"Referencing internal functions"}),"\n",(0,s.jsx)(n.p,{children:"Referencing internal functions is usually pretty simple."}),"\n",(0,s.jsx)(n.h3,{id:"non-static-function",children:"Non-static function"}),"\n",(0,s.jsx)(n.p,{children:"Here is an example for a non-static function:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:"inline void ctor(Pml::PokePara::InitialSpec::Object* spec) {\r\n  external<void>(0x02055140, this, spec);\r\n}\n"})}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"external<T>()"})," does most of the work for you. All you have to do is give it, in that order:"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"The offset for the start of the function"}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"this"}),", the current instance of the object"]}),"\n",(0,s.jsx)(n.li,{children:"All the arguments to call the function with, in order"}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["If there is a return type that is not ",(0,s.jsx)(n.code,{children:"void"}),", you can simply return the result of ",(0,s.jsx)(n.code,{children:"external<T>()"})," directly. ",(0,s.jsx)(n.strong,{children:"Make sure you do not return if the return type is"})," ",(0,s.jsx)(n.code,{children:"void"}),(0,s.jsx)(n.strong,{children:"! This is undefined behavior and could cause crashes."})]}),"\n",(0,s.jsx)(n.h3,{id:"static-function",children:"Static function"}),"\n",(0,s.jsx)(n.p,{children:"For a static function, the format is similar but changes slightly:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:"static inline bool IsGet(int32_t id) {\r\n  return external<bool>(0x01d603e0, id);\r\n}\n"})}),"\n",(0,s.jsxs)(n.p,{children:["The two differences are the addition of the ",(0,s.jsx)(n.code,{children:"static"})," keyword at the front of the function, and not passing ",(0,s.jsx)(n.code,{children:"this"})," to ",(0,s.jsx)(n.code,{children:"external<T>()"}),". The rest is the same."]}),"\n",(0,s.jsxs)(n.p,{children:["You can generally tell if a function is static or not by its arguments. If the first argument in ghidra is of the class's type and has the name ",(0,s.jsx)(n.code,{children:"__this"}),", then it's usually non-static."]}),"\n",(0,s.jsx)(n.h3,{id:"methodinfo",children:"MethodInfo"}),"\n",(0,s.jsx)(n.p,{children:"99% of the time, we can ignore the MethodInfo argument that is always the last argument of a function. It'll always be 0 or null."}),"\n",(0,s.jsxs)(n.p,{children:["In the rare chance that the MethodInfo of a function you wish to call ",(0,s.jsx)(n.strong,{children:"is"})," needed, its type will generally have the offset of the function appended to it (something like ",(0,s.jsx)(n.code,{children:"MethodInfo_1CFA100"}),")."]}),"\n",(0,s.jsx)(n.p,{children:"You can declare the function similarly to this:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:"template <typename T>\r\ninline T::Object* GetCurrentUIWindow(ILMethod<T>& method) {\r\n  return external<typename T::Object*>(0x01cfa100, this, *method);\r\n}\n"})}),"\n",(0,s.jsxs)(n.p,{children:["In the ",(0,s.jsx)(n.code,{children:"ILClass"}),", you should define a ",(0,s.jsx)(n.code,{children:"StaticILMethod"})," to use when calling:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:"static inline StaticILMethod<0x04c90130, Dpr::UI::UIWindow> Method$$GetCurrentUIWindow_UIWindow_ {};\n"})}),"\n",(0,s.jsxs)(n.p,{children:["And when calling it, you can pass in this ",(0,s.jsx)(n.code,{children:"StaticILMethod"})," like so:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:"auto window = uiManager->GetCurrentUIWindow(Dpr::UI::UIManager::Method$$GetCurrentUIWindow_UIWindow_);\n"})}),"\n",(0,s.jsx)(n.h2,{id:"usage",children:"Usage"}),"\n",(0,s.jsx)(n.p,{children:"When using these headers you've created, there's a few things to keep in mind."}),"\n",(0,s.jsx)(n.h3,{id:"ghidra-type-equivalence",children:"Ghidra type equivalence"}),"\n",(0,s.jsxs)(n.p,{children:["Types that end in ",(0,s.jsx)(n.code,{children:"_o"})," refer to an Object. You'll want to declare your variables similarly to this:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:"Pml::PokePara::PokemonParam::Object* pokeParam = //...\n"})}),"\n",(0,s.jsxs)(n.p,{children:["Types that end in ",(0,s.jsx)(n.code,{children:"_c"})," refer to a Class. You can access it through the ",(0,s.jsx)(n.code,{children:"getClass()"})," static function, when the TypeInfo is defined."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:"Pml::PokePara::PokemonParam::Class* pokeParamClass = Pml::PokePara::PokemonParam::getClass();\n"})}),"\n",(0,s.jsxs)(n.p,{children:["Types that end in ",(0,s.jsx)(n.code,{children:"_Fields"})," refer to the fields. You can access them through the Object like this:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:"Pml::PokePara::PokemonParam::Fields pokeParamFields = pokeParam->fields;\n"})}),"\n",(0,s.jsxs)(n.p,{children:["Types that end in ",(0,s.jsx)(n.code,{children:"_StaticFields"})," refer to the static fields. You can access them through the Class like this:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:"Pml::PokePara::PokemonParam::StaticFields* pokeParamStaticFields = pokeParamClass->static_fields;\n"})}),"\n",(0,s.jsxs)(n.p,{children:["Types that end in ",(0,s.jsx)(n.code,{children:"_array"})," refer to an array of Objects. You can declare one like so:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:"Pml::PokePara::PokemonParam::Array* pokeParamArray = //...\n"})}),"\n",(0,s.jsx)(n.h3,{id:"new-instance",children:"New instance"}),"\n",(0,s.jsxs)(n.p,{children:["You can create new Object instances with the ",(0,s.jsx)(n.code,{children:"newInstance()"})," function. It will call the defined ",(0,s.jsx)(n.code,{children:"ctor"})," function that matches the given arguments. For example, for a defined ",(0,s.jsx)(n.code,{children:"ctor"})," that looks like this:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:"inline void ctor(Pml::PokePara::InitialSpec::Object* spec) {\r\n  external<void>(0x02055140, this, spec);\r\n}\n"})}),"\n",(0,s.jsxs)(n.p,{children:["You can create a new instance (in this case, it's a ",(0,s.jsx)(n.code,{children:"Pml::PokePara::PokemonParam::Object*"}),") like so:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:"Pml::PokePara::InitialSpec::Object* initialSpec = //...\r\nPml::PokePara::PokemonParam::Object* param = Pml::PokePara::PokemonParam::newInstance(initialSpec);\n"})}),"\n",(0,s.jsxs)(n.p,{children:["And this will automatically call the appropriate memory allocation functions and the ",(0,s.jsx)(n.code,{children:"ctor"})," function defined above."]})]})}function h(e={}){const{wrapper:n}={...(0,a.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(d,{...e})}):d(e)}}}]);